class RecyclingPlant

instance variables

rcTrucks : set of GarbageTruck := {};

sortedGarbage : GarbageSorter`GarbageMap := {   <GLASSID>   |-> {},
                                                <METALID>   |-> {},
                                                <PAPERID>   |-> {},
                                                <PLASTICID> |-> {}
                                            };


operations

-- Sort the trucks, and then show the sorted garbage
public Step : () ==> ()
Step() == (
    dcl sortedMap : GarbageSorter`GarbageMap := sortAllTrucks();
        handleGarbageMap(sortedMap);
);


private handleGarbageMap : GarbageSorter`GarbageMap ==> ()
handleGarbageMap(gpMap) ==
(
    IO`println("Sorted Garbage: ");
    for all gptype in set dom gpMap do
    (
        cases gptype:
            <GLASSID> -> IO`println("Glass: "),
            <METALID> -> IO`println("Metal: "),
            <PAPERID> -> IO`println("Paper: "),
            <PLASTICID> -> IO`println("Plastic: "),
            others -> skip
        end;

        -- Set can abstract the maps set as a Large GarbagePack, therefore these functions work
        IO`println("Weight");
        IO`println(GLOBAL`SumWeightGarbagePack(gpMap(gptype)));
        IO`println("Volume");
        IO`println(GLOBAL`SumDimensionGarbagePack(gpMap(gptype)));

    );
);

public addFilledTrucksToPlant : set of GarbageTruck ==> ()
addFilledTrucksToPlant(filledTruck) == 
    rcTrucks := rcTrucks union filledTruck;

private sortAllTrucks : () ==> GarbageSorter`GarbageMap
sortAllTrucks() == (
    for all t in set rcTrucks
        do 
            let x = getSeqOfIndividualGarbageFromTruck(t) in
                sortedGarbage := GarbageSorter`MapCombine(sortedGarbage,GarbageSorter`sortSetofGarbagePack(x));
    return sortedGarbage 
);


functions
private getSeqOfIndividualGarbageFromTruck : GarbageTruck -> set of GarbageType
getSeqOfIndividualGarbageFromTruck(gbTruck) == (
    dunion {i.getGarbagePack() | i in set gbTruck.getTruckGarbage()}
);


end RecyclingPlant